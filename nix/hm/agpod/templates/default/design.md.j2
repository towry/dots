# {{ desc }} Design Document

<!-- multiple requirement-design-documents -->

# REQ-[FUNCTIONAL-AREA-SLUG]: [Requirement Title]

### Traceability

| Requirement ID | Owner | Status | Target Date | Notes/Links |
| -------------- | ----- | ------ | ----------- | ----------- |
| REQ-[FUNCTIONAL-AREA-SLUG] | [Owner Name] | [Draft/In design/In build/Done] | [YYYY-MM-DD] | [Link to tracker/RACI] |

## Overview

[Brief description of the feature and its purpose]

**Prerequisites**: [List any prerequisites or dependencies]

### Key Objectives
- [Objective 1]
- [Objective 2]

### Success Metrics
- [Metric 1: target and measurement cadence]
- [Metric 2]

### Non-goals and Scope Limitations
- [Non-goal 1]
- [Non-goal 2]


### Dependencies & Risks
- **Dependency**: [Description] — **Owner**: [Name] — **Status**: [Not started/In progress/At risk] — **Mitigation**: [Plan or fallback]
- **Risk**: [Description] — **Impact**: [High/Med/Low] — **Likelihood**: [High/Med/Low] — **Mitigation/Owner**: [Plan/Name]


## Architecture

### System Design

```
[ASCII diagram showing system components and their relationships]
```

### Data Flow

1. **[Flow Name]**
   - [Step 1]
   - [Step 2]

## Components and Interfaces

[Optional: Organize by layers (e.g., service layer, data layer, integration layer) or by functional modules]

### Component 1: [Component Name]

[Description of component interface, key methods, and responsibilities]

### Component 2: [Component Name]

[Description of how this integrates with existing system]

## Data Models

### Configuration

[List of configuration settings with keys, default values, and descriptions]

### Data Structures

[Optional: Include when feature requires specific data structures, schemas, or type definitions]

#### [Structure Name]
[Description of data structure, fields, types, and constraints]

### API Contracts

[Optional: Include when feature involves API integration or defines interfaces]

#### 1. [Interface/Endpoint Name]
[Description of contract: input/output format, protocol, and purpose]

## Implementation Details

### Proof of Concept (PoC)

[Optional: Include this section when the feature involves unfamiliar technology, integration risks, or uncertain performance characteristics]

#### Experiment Goals
- [What technical uncertainty needs validation?]
- [What integration risks need testing?]

#### Validation Steps
1. [Minimal test setup]
2. [Key scenarios to verify]
3. [Success criteria]

#### Findings
- [What worked / didn't work]
- [Performance observations]
- [Integration challenges discovered]

#### Next Actions
- [Adjustments needed based on PoC results]
- [Risks mitigated or still outstanding]

### Design for Testability

[Include this section to ensure components are designed for effective testing from the start]

#### Testability Principles Applied

1. **Dependency Injection**
   - [Which components use DI and why]
   - [How dependencies are injected (constructor, setter, factory)]

2. **Controllability & Observability**
   - [How system state can be set for testing]
   - [What internal states/outputs are observable]
   - [Seams created for behavior modification in tests]

3. **Isolation Strategy**
   - [Which components can be tested independently]
   - [Interface abstractions enabling mock/stub usage]
   - [External dependencies that require test doubles]

4. **Pure Functions & State Management**
   - [Which functions are side-effect free]
   - [How global/shared state is minimized or avoided]
   - [Deterministic behavior guarantees]

#### Test Doubles & Mocking Strategy

- **[Component/Interface Name]**: [Mock/Stub/Fake strategy and rationale]
- **[External Service]**: [How it will be isolated in tests]

#### Testability Trade-offs

- [Any design compromises made for testability]
- [Performance or complexity impacts]
- [Boundaries where testability is deprioritized and why]

### Key Algorithms

[Optional: Include this section when the feature requires non-trivial algorithms or complex logic]

#### 1. [Algorithm Name]
[High-level description of algorithm logic, inputs, outputs, and key steps]

### Performance Considerations

1. **[Performance Aspect]**
   - [Consideration 1]
   - [Consideration 2]

### Security Considerations

1. **[Security Aspect]**
   - [Consideration 1]
   - [Consideration 2]

## Error Handling

### Error Scenarios

1. **[Error Category]**
   - [Error type 1]: [Handling approach]
   - [Error type 2]: [Handling approach]

### Error Handling Implementation
[Description of error handling strategy, retry logic, and fallback behavior]

## Testing Strategy

### Acceptance / Exit Criteria

1. [Criterion 1]
2. [Criterion 2]

### Unit Tests

1. **[Test Category]**
   - [Test scenario 1]
   - [Test scenario 2]

### Integration Tests

1. **[Integration Scenario]**
   - [Test scenario 1]
   - [Test scenario 2]

## Migration and Rollout

### Backwards Compatibility

1. **[Compatibility Aspect]**
   - [Consideration 1]
   - [Consideration 2]

### Deployment Strategy

[Optional: Include when feature requires specific deployment steps or coordination]

1. **[Deployment Phase]**
   - [Step 1]
   - [Step 2]

### Rollback / Recovery

- [Trigger conditions for rollback]
- [Rollback steps]
- [Data recovery/cleanup steps]

---

# REQ-[ANOTHER-FEATURE-SLUG]: [Requirement Title]

