# yaml-language-server: $schema=https://raw.githubusercontent.com/antinomyhq/forge/refs/heads/main/forge.schema.json
updates:
  auto_update: false
commands:
  - name: background
    description: Delegate command to run
    prompt: >-
      Delegate the prompt to the hog tool
  - name: follow_plan_track
    description: Follow the PLAN.md and TRACK.md files to implement the plan
    prompt: >-
      Follow the PLAN.md and TRACK.md files to implement the plan
  - name: save_memory
    description: Save important context to memory for future reference
    prompt: >-
      Use memory tool save current important context to memory for future reference
  - name: commit
    description: Commit changes or update description of rev
    prompt: >-
      Ask "jj" subagent to update the provided rev with proper commit message or commit the working copy if rev is not provided.
      The rev is "{{event.value}}", it maybe empty
  - name: review
    description: Review code changes
    prompt: >-
      Ask "jj" subagent to provide the git diff of rev or the working copy if rev is not provided.
      then ask oracle subagent to review the code changes and provide feedback.
      The context is "{{event.value}}", it maybe empty
agents:
  - id: software-engineer
    tool_supported: true
    system_prompt: |-
      {{#if (eq variables.mode "PLAN") }}
      {{> system-prompt-engineer-plan.hbs }}
      {{else}}
      {{> system-prompt-engineer-act.hbs }}
      {{/if}}
    user_prompt: |-
      <task>{{event.value}}</task>
      <current_time>{{current_time}}</current_time>
custom_rules: >-
  # Critical and general rules

  Avoid over-engineering. Prefer simple, correct, and maintainable solutions.

  1. Be Organized: Use numbered lists for options, steps, or requirements
  2. Be Transparent: Use FIXME, TODO, NOTE when relevant
  3. Be Clear: Document assumptions and requirements briefly in comments
  4. Gather Context: Ask for missing info before implementing
  5. Explicit over Implicit: If the intent is unclear, provide a list of guessed options and allow the user to make a selection
  6. Separation of Concerns: Keep boundaries clear; confirm before crossing layers
  7. Be Humble: Recognize your limitations and seek assistance when facing challenges
  8. Seek user approval for your implementation plan before proceeding
  9. Correct user's English grammar and spelling mistakes, ensuring not to alter any quoted or copied content such as code snippets, by starting with "Let's rephrase for clarity: "

  # When implementing and fixing

  - Clarify Requirements: Ask questions when tasks are unclear
  - Validate Requirements: Identify key specifications and edge cases
  - Break Down Tasks: Split complex tasks into small, verifiable steps for better clarity and manageability
  - Consider Scope: Check impact on surrounding code
  - Avoid integrating _mock code_ into intermediate layers. Ensure that the foundational implementation is finalized, and contain all mocking behavior in the highest layer.
  - Use annotations like FIXME, TODO, and NOTE to highlight areas that require attention, further improvement, or documentation for future reference
  - Write helpful comments for “why”, prefer self-documenting code for “what”
  - Prioritize correctness and clarity over micro-optimizations
  - Follow DRY pragmatically: apply SOLID principles when they improve readability
    and maintainability; avoid unnecessary abstractions that do not solve a clear
    problem.
  - Use descriptive constants instead of magic numbers (e.g., const MAX_RETRIES =
    3).
  - Preserve existing structure and style unless they contradict project standards
    or cause readability/maintainability issues.
  - Prefer dependency injection and localized state over globals: allow direct
    access in small standalone scripts or configuration files where DI overhead
    outweighs its benefit.
  - Use explicit parameter passing instead of parent/ambient access
  - Don’t break existing functionality without understanding impact
  - Only modify code relevant to the task: any cross-module or cross-layer changes
    must be documented and justified.
  - Prefer simple solutions that minimize side effects and blast radius
  - **Fail Fast, Don't Hide Bugs**: Avoid using try-catch blocks, optional chaining (`?.`), or other defensive coding techniques to silence errors that indicate a contract violation. Instead, prefer fail-fast and allow the system to quickly detect and report errors. If an object is expected to have a certain method or property, its absence is a bug that should be surfaced immediately. Hiding such errors leads to deferred failures that are much harder to debug.


  **Good function signature design**

  - Pass only needed primitives, not entire objects
  - Use clear parameter names that reveal purpose
  - When passing objects, document exact properties used

  Example: ✗ Bad: `downloadResume(candidateData, $store, componentInstance)` ✓
  Good: `downloadResume(candidateId, candidateName, authToken)`

  **Error Handling**

  1. Prefer explicit error propagation over silent failures
  2. Validate behavior preservation during refactoring
  3. Update documentation and tests for significant changes
  4. Ask for help when details are needed for decisions
  5. Avoid duplicate user-facing error messages across layers

  # When testing

  1. Use BDD: GIVEN/WHEN/THEN
  2. Write descriptive test names by scenario
  3. Use `actual` for results and `expected` for assertions
  4. Test one behavior per test

  # When debugging

  1. Verify that no existing debug or development processes are running
  2. Run shell command `curl -I <dev-server-address>` to check dev server before
    starting a new one
  3. Ask user to commit current changes before running lint/format to avoid unexpected
    diffs

  # When researching code

  1. *Shell* Utilize `fd` to find files and `rg` to search within file contents
  2. *MCP tools* When using MCP tools, provide absolute file paths
  3. Package Managers: Detect the correct one (npm/pnpm/yarn)
  4. *Shell* Kill process that owning a port: `killport <port>`
  5. *Shell* Running shell commands: Use shell commands in fish shell
  6. *Git* View file changed vs main in git repo: `jj df-file-base <file-path>`
  7. *Git* View file changed vs previous commit in git repo: `jj df-file-prev <file-path>`
