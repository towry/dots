name: Typos Check

on:
  pull_request:
    branches: [main]
    paths:
      - "**/*.md"
      - "**/*.markdown"
      - "**/*.sh"
      - "**/*.bash"
      - "**/*.txt"
      - "**/*.py"
      - "**/*.js"
      - "**/*.ts"
      - "**/*.yml"
      - "**/*.yaml"
      - "**/*.json"
      - "**/*.toml"
  push:
    branches: [main]
    paths:
      - "**/*.md"
      - "**/*.markdown"
      - "**/*.sh"
      - "**/*.bash"
      - "**/*.txt"
      - "**/*.py"
      - "**/*.js"
      - "**/*.ts"
      - "**/*.yml"
      - "**/*.yaml"
      - "**/*.json"
      - "**/*.toml"
  workflow_dispatch:

jobs:
  typos-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install typos CLI
        run: |
          curl -LsSf https://github.com/crate-ci/typos/releases/download/v1.40.0/typos-v1.40.0-x86_64-unknown-linux-musl.tar.gz | sudo tar xzf - -C /usr/local/bin

      - name: Check for typos
        id: typos_check
        run: |
          # Run typos with JSON output format
          typos --config ./typos.toml . --format json > typos-output.json 2>&1 || true

          # Check if typos were found (exit code 2) or other errors occurred
          if [ -f typos-output.json ] && [ -s typos-output.json ]; then
            # Typos found - use base64 encoding to handle special characters and newlines
            ERRORS_B64=$(cat typos-output.json | base64 -w 0)
            echo "typos_errors=$ERRORS_B64" >> $GITHUB_OUTPUT
            echo "found_typos=true" >> $GITHUB_OUTPUT
          else
            # No typos found or errors
            echo "typos_errors=" >> $GITHUB_OUTPUT
            echo "found_typos=false" >> $GITHUB_OUTPUT
          fi

      - name: Comment on PR with typos results
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('Starting comment creation script...');
            try {
              const foundTypos = `${{ steps.typos_check.outputs.found_typos }}` === 'true';
              const encodedErrors = `${{ steps.typos_check.outputs.typos_errors }}`;

              console.log('foundTypos:', foundTypos);
              console.log('encodedErrors length:', encodedErrors ? encodedErrors.length : 0);
              console.log('Context Issue Number:', context.issue.number);
              console.log('Context Payload Pull Request Number:', context.payload.pull_request ? context.payload.pull_request.number : 'None');

              const prNumber = context.issue.number || (context.payload.pull_request ? context.payload.pull_request.number : null);

              if (!prNumber) {
                console.log('No PR number found, skipping comment');
                return;
              }

              let commentBody;

              if (!foundTypos) {
                // No typos found - success message
                commentBody = `## âœ… Typos Check Passed\n\nNo spelling errors found! The codebase is clean.\n\n*Automated comment from typos-check workflow* ðŸ¤–`;
              } else {
                // Typos found - error message
                if (!encodedErrors || encodedErrors.trim() === '') {
                  console.log('No encoded errors found but foundTypos is true');
                  commentBody = `## âŒ Typos Check Failed\n\nTypos were detected but error details could not be captured.\n\n*Automated comment from typos-check workflow* ðŸ¤–`;
                } else {
                  try {
                    const typosJson = Buffer.from(encodedErrors, 'base64').toString('utf8');
                    // Split the JSON Lines format into individual objects
                    const typosLines = typosJson.trim().split('\n').filter(line => line.trim() !== '');
                    const typos = [];

                    for (const line of typosLines) {
                      try {
                        if (line.trim().startsWith('{')) {
                          typos.push(JSON.parse(line));
                        }
                      } catch (e) {
                        console.log('Failed to parse line as JSON:', line);
                      }
                    }

                    console.log('Parsed typos count:', typos.length);

                    if (typos.length === 0) {
                       commentBody = `## âŒ Typos Check Failed\n\nTypos were detected but the output format was unexpected.\n\n*Automated comment from typos-check workflow* ðŸ¤–`;
                    } else {
                      // Group typos by file for better organization
                      const typosByFile = {};
                      typos.forEach(typo => {
                        if (!typosByFile[typo.path]) {
                          typosByFile[typo.path] = [];
                        }
                        typosByFile[typo.path].push(typo);
                      });

                      // Create formatted comment with links
                      commentBody = `## âŒ Typos Check Failed\n\n`;
                      commentBody += `Found ${typos.length} spelling error(s) that need to be corrected:\n\n`;

                      // Add each file's typos with GitHub links
                      for (const [filePath, fileTypos] of Object.entries(typosByFile)) {
                        fileTypos.forEach(typo => {
                          const lineNum = typo.line_num || 'unknown';
                          const permalink = lineNum !== 'unknown'
                            ? `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${context.sha}/${filePath}?plain=1#L${lineNum}`
                            : `https://github.com/${context.repo.owner}/${context.repo.repo}/blob/${context.sha}/${filePath}?plain=1`;

                          const corrections = typo.corrections || typo.correction || [typo.replacement] || [];
                          if (corrections.length === 0 || !corrections[0]) {
                            commentBody += `- [${filePath}:${lineNum}](${permalink}): \`${typo.typo}\`\n`;
                          } else {
                            commentBody += `- [${filePath}:${lineNum}](${permalink}): \`${typo.typo}\` should be \`${corrections.join('\`, \`')}\`\n`;
                          }
                        });
                        commentBody += `\n`;
                      }

                      commentBody += `Please fix these typos before merging. For more information, see [typos documentation](https://github.com/crate-ci/typos).\n\n`;
                      commentBody += `*Automated comment from typos-check workflow* ðŸ¤–`;
                    }
                  } catch (decodeError) {
                    console.error('Error decoding/parsing typos:', decodeError);
                    commentBody = `## âŒ Typos Check Failed\n\nFound spelling errors but failed to parse details. Check workflow logs for raw output.\n\n*Automated comment from typos-check workflow* ðŸ¤–`;
                  }
                }
              }

              // Check if a comment already exists
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });

              const botComments = comments.filter(comment =>
                comment.user.login === 'github-actions[bot]' &&
                (comment.body.includes('Typos Check') || comment.body.includes('typos-check workflow'))
              );

              if (botComments.length > 0) {
                // Update existing comment
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComments[0].id,
                  body: commentBody
                });
                console.log('Updated existing comment:', botComments[0].id);
              } else {
                // Create new comment
                const newComment = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: commentBody
                });
                console.log('Created new comment:', newComment.data.id);
              }
            } catch (error) {
              console.error('Critical error in comment creation:', error);
            }

      - name: Fail if typos found
        if: steps.typos_check.outputs.found_typos == 'true'
        run: |
          echo "Typos were found. Please fix them to pass the check."
          exit 1
